This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: lib/**/*, pubspec.yaml, analysis_options.yaml
- Files matching these patterns are excluded: **/build/**, **/.dart_tool/**, **/.git/**, **/android/**, **/ios/**, **/web/**, **/linux/**, **/macos/**, **/windows/**, **/*.png, **/*.jpg
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
analysis_options.yaml
lib/core/constants/app_strings.dart
lib/core/constants/supabase_constants.dart
lib/core/local_db/app_database.dart
lib/core/local_db/db_instance.dart
lib/core/local_db/tables/local_vocab_progress.dart
lib/core/services/supabase_service.dart
lib/core/ultis/auth_helper.dart
lib/core/ultis/logger.dart
lib/features/auth/data/auth_service.dart
lib/features/auth/presentation/auth_gate.dart
lib/features/auth/presentation/login_page.dart
lib/features/auth/presentation/register_page.dart
lib/features/features.txt
lib/features/vocabulary/data/datasources/category_remote_datasource.dart
lib/features/vocabulary/data/datasources/vocabulary_remote_datasource.dart
lib/features/vocabulary/data/models/category_model.dart
lib/features/vocabulary/data/models/vocabulary_model.dart
lib/features/vocabulary/data/models/vocabulary.dart
lib/features/vocabulary/data/repositories/vocabulary_repository.dart
lib/features/vocabulary/presentation/pages/vocabulary_detail_page.dart
lib/features/vocabulary/presentation/pages/vocabulary_form_page.dart
lib/features/vocabulary/presentation/pages/vocabulary_list_page.dart
lib/features/vocabulary/presentation/pages/vocabulary_quiz_page.dart
lib/features/vocabulary/presentation/widgets/vocabulary_card.dart
lib/features/vocabulary/vocabulary_routes.dart
lib/main.dart
lib/shared/themes/app_theme.dart
lib/shared/widgets/app_button.dart
pubspec.yaml
```

# Files

## File: analysis_options.yaml
```yaml
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options
```

## File: lib/core/constants/app_strings.dart
```dart

```

## File: lib/core/constants/supabase_constants.dart
```dart

```

## File: lib/core/local_db/app_database.dart
```dart
// import 'dart:io';
// import 'package:drift/drift.dart';
// import 'package:drift/native.dart';
// import 'package:path/path.dart' as p;
// import 'package:path_provider/path_provider.dart';

// import 'tables/local_vocab_progress.dart';

// part 'app_database.g.dart';

// @DriftDatabase(tables: [LocalVocabProgress])
// class AppDatabase extends _$AppDatabase {
//   AppDatabase() : super(_openConnection());

//   @override
//   int get schemaVersion => 1;

//   Future<LocalVocabProgressData?> getProgress(int vocabId) {
//     return (select(localVocabProgress)
//       ..where((t) => t.vocabId.equals(vocabId))).getSingleOrNull();
//   }

//   Future<void> upsertProgress({
//     required int vocabId,
//     bool? learned,
//     bool? favorite,
//   }) async {
//     final existing = await getProgress(vocabId);

//     await into(localVocabProgress).insertOnConflictUpdate(
//       LocalVocabProgressCompanion(
//         vocabId: Value(vocabId),
//         learned:
//             learned != null
//                 ? Value(learned)
//                 : Value(existing?.learned ?? false),
//         favorite:
//             favorite != null
//                 ? Value(favorite)
//                 : Value(existing?.favorite ?? false),
//       ),
//     );
//   }
// }

// LazyDatabase _openConnection() {
//   return LazyDatabase(() async {
//     final dir = await getApplicationDocumentsDirectory();
//     final file = File(p.join(dir.path, 'nihongo_local.db'));
//     return NativeDatabase(file);
//   });
// }
```

## File: lib/core/local_db/db_instance.dart
```dart
// import 'app_database.dart';

// final appDatabase = AppDatabase();
```

## File: lib/core/local_db/tables/local_vocab_progress.dart
```dart
import 'package:drift/drift.dart';

class LocalVocabProgress extends Table {
  IntColumn get vocabId => integer()();
  BoolColumn get learned => boolean().withDefault(const Constant(false))();
  BoolColumn get favorite => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {vocabId};
}
```

## File: lib/core/services/supabase_service.dart
```dart
// lib/core/services/supabase_service.dart

import 'package:supabase_flutter/supabase_flutter.dart';

class SupabaseService {
  static late SupabaseClient client;

  static Future<void> init() async {
    await Supabase.initialize(
      url: 'https://khywpgvcmkwvufquiudy.supabase.co',
      anonKey:
          'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtoeXdwZ3ZjbWt3dnVmcXVpdWR5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk1MDQ2NDAsImV4cCI6MjA4NTA4MDY0MH0.f-no2MOG1fBtbcV73E4z2ALxtWhsbKF4Hz7YwFQQtDA',
    );

    client = Supabase.instance.client;
  }
}
```

## File: lib/core/ultis/auth_helper.dart
```dart
import 'package:supabase_flutter/supabase_flutter.dart';

class AuthHelper {
  static User? get currentUser => Supabase.instance.client.auth.currentUser;

  static bool get isGuest => currentUser == null;
}
```

## File: lib/core/ultis/logger.dart
```dart

```

## File: lib/features/auth/data/auth_service.dart
```dart
import 'package:supabase_flutter/supabase_flutter.dart';

class AuthService {
  final _client = Supabase.instance.client;

  User? get currentUser => _client.auth.currentUser;

  Future<AuthResponse> signInEmail(String email, String password) {
    return _client.auth.signInWithPassword(email: email, password: password);
  }

  Future<AuthResponse> signUpEmail(String email, String password) {
    return _client.auth.signUp(email: email, password: password);
  }

  Future<void> signInWithGoogle() async {
    await _client.auth.signInWithOAuth(
      OAuthProvider.google,
      redirectTo: 'io.supabase.flutter://login-callback',
    );
  }

  Future<void> signOut() async {
    await _client.auth.signOut();
  }
}
```

## File: lib/features/auth/presentation/auth_gate.dart
```dart
import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import '../../vocabulary/presentation/pages/vocabulary_list_page.dart';
import 'login_page.dart';

class AuthGate extends StatelessWidget {
  const AuthGate({super.key});

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<AuthState>(
      stream: Supabase.instance.client.auth.onAuthStateChange,
      builder: (context, snapshot) {
        final session = snapshot.data?.session;

        if (session == null) {
          return const LoginPage();
        } else {
          return const VocabularyListPage();
        }
      },
    );
  }
}
```

## File: lib/features/auth/presentation/login_page.dart
```dart
import 'package:flutter/material.dart';
import '../data/auth_service.dart';

class LoginPage extends StatefulWidget {
  const LoginPage({super.key});

  @override
  State<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends State<LoginPage> {
  final auth = AuthService();
  final emailCtrl = TextEditingController();
  final passCtrl = TextEditingController();
  bool loading = false;

  Future<void> login() async {
    setState(() => loading = true);
    try {
      await auth.signInEmail(emailCtrl.text, passCtrl.text);
    } catch (e) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text(e.toString())));
    }
    setState(() => loading = false);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Login')),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            TextField(
              controller: emailCtrl,
              decoration: const InputDecoration(labelText: 'Email'),
            ),
            TextField(
              controller: passCtrl,
              decoration: const InputDecoration(labelText: 'Password'),
              obscureText: true,
            ),
            const SizedBox(height: 16),

            ElevatedButton(
              onPressed: loading ? null : login,
              child: const Text('Login'),
            ),

            const SizedBox(height: 12),

            ElevatedButton.icon(
              icon: const Icon(Icons.login),
              label: const Text('Login with Google'),
              onPressed: auth.signInWithGoogle,
            ),
          ],
        ),
      ),
    );
  }
}
```

## File: lib/features/auth/presentation/register_page.dart
```dart

```

## File: lib/features/vocabulary/data/datasources/category_remote_datasource.dart
```dart
import '../../../../core/services/supabase_service.dart';
import '../models/category_model.dart';

class CategoryRemoteDatasource {
  final _client = SupabaseService.client;

  Future<List<CategoryModel>> getVocabularyCategories() async {
    final response = await _client
        .from('categories')
        .select()
        .eq('type', 'vocab')
        .order('order_index');

    return (response as List).map((e) => CategoryModel.fromJson(e)).toList();
  }
}
```

## File: lib/features/vocabulary/data/models/category_model.dart
```dart
class CategoryModel {
  final int id;
  final String title;

  CategoryModel({required this.id, required this.title});

  factory CategoryModel.fromJson(Map<String, dynamic> json) {
    return CategoryModel(id: json['id'], title: json['title']);
  }
}
```

## File: lib/features/vocabulary/presentation/pages/vocabulary_detail_page.dart
```dart

```

## File: lib/features/vocabulary/presentation/pages/vocabulary_quiz_page.dart
```dart
import 'dart:math';
import 'package:flutter/material.dart';
import '../../data/models/vocabulary.dart';

class VocabularyQuizPage extends StatefulWidget {
  final List<Vocabulary> vocabList;

  const VocabularyQuizPage({super.key, required this.vocabList});

  @override
  State<VocabularyQuizPage> createState() => _VocabularyQuizPageState();
}

class _VocabularyQuizPageState extends State<VocabularyQuizPage> {
  late Vocabulary current;
  late List<String> options;
  String? selected;
  bool answered = false;

  @override
  void initState() {
    super.initState();
    nextQuestion();
  }

  void nextQuestion() {
    final rnd = Random();

    current = widget.vocabList[rnd.nextInt(widget.vocabList.length)];

    final others =
        widget.vocabList.where((v) => v.id != current.id).toList()..shuffle();

    options = [
      current.meaningEn,
      others[0].meaningEn,
      others[1].meaningEn,
      others[2].meaningEn,
    ]..shuffle();

    selected = null;
    answered = false;

    setState(() {});
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Vocabulary Quiz')),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            Text(
              current.kanji.isNotEmpty ? current.kanji : current.hiragana,
              style: const TextStyle(fontSize: 32, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 24),

            ...options.map((o) {
              final isCorrect = o == current.meaningEn;
              Color? color;

              if (answered) {
                if (o == selected) {
                  color = isCorrect ? Colors.green : Colors.red;
                } else if (isCorrect) {
                  color = Colors.green;
                }
              }

              return Card(
                color: color,
                child: ListTile(
                  title: Text(o),
                  onTap:
                      answered
                          ? null
                          : () {
                            setState(() {
                              selected = o;
                              answered = true;
                            });
                          },
                ),
              );
            }),

            const Spacer(),

            ElevatedButton(
              onPressed: answered ? nextQuestion : null,
              child: const Text('Next'),
            ),
          ],
        ),
      ),
    );
  }
}
```

## File: lib/features/vocabulary/presentation/widgets/vocabulary_card.dart
```dart

```

## File: lib/features/vocabulary/vocabulary_routes.dart
```dart

```

## File: lib/shared/themes/app_theme.dart
```dart

```

## File: lib/shared/widgets/app_button.dart
```dart

```

## File: lib/features/vocabulary/data/datasources/vocabulary_remote_datasource.dart
```dart
// lib/features/vocabulary/data/datasources/vocabulary_remote_datasource.dart

import '../../../../core/services/supabase_service.dart';
import '../models/vocabulary_model.dart';

class VocabularyRemoteDatasource {
  final _client = SupabaseService.client;

  Future<List<VocabularyModel>> getAll() async {
    final response = await _client.from('vocabulary').select().order('id');

    return (response as List).map((e) => VocabularyModel.fromJson(e)).toList();
  }

  Future<void> insert(VocabularyModel vocab) async {
    await _client.from('vocabulary').insert(vocab.toJson());
  }

  Future<void> update(int id, VocabularyModel vocab) async {
    await _client.from('vocabulary').update(vocab.toJson()).eq('id', id);
  }

  Future<void> delete(int id) async {
    await _client.from('vocabulary').delete().eq('id', id);
  }

  Future<void> updateFavorite(int id, bool value) async {
    await _client
        .from('vocabulary')
        .update({'is_favorite': value})
        .eq('id', id);
  }

  Future<void> updateLearned(int id, bool value) async {
    await _client.from('vocabulary').update({'is_learned': value}).eq('id', id);
  }
}
```

## File: lib/features/vocabulary/data/models/vocabulary.dart
```dart
class Vocabulary {
  final int id;
  final int categoryId;
  final String kanji;
  final String hiragana;
  final String romaji;
  final String meaningVn;
  final String meaningEn;
  final bool isFavorite;
  final bool isLearned;

  Vocabulary({
    required this.id,
    required this.categoryId,
    required this.kanji,
    required this.hiragana,
    required this.romaji,
    required this.meaningVn,
    required this.meaningEn,
    required this.isFavorite,
    required this.isLearned,
  });

  factory Vocabulary.fromMap(Map<String, dynamic> map) {
    return Vocabulary(
      id: map['id'],
      categoryId: map['category_id'],
      kanji: map['kanji'] ?? '',
      hiragana: map['hiragana'] ?? '',
      romaji: map['romaji'] ?? '',
      meaningVn: map['meaning_vn'] ?? '',
      meaningEn: map['meaning_en'] ?? '',
      isFavorite: map['is_favorite'] ?? false,
      isLearned: map['is_learned'] ?? false,
    );
  }
}
```

## File: pubspec.yaml
```yaml
name: nihongo_app
description: "A new Flutter project."
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: ^3.7.2

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.8
  supabase_flutter: ^2.12.0

  drift: ^2.16.0
  sqlite3_flutter_libs: ^0.5.20
  path_provider: ^2.1.2
  path: ^1.9.0

dev_dependencies:
  flutter_test:
    sdk: flutter

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^5.0.0
  drift_dev: ^2.16.0
  build_runner: ^2.4.8

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/to/resolution-aware-images

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/to/asset-from-package

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/to/font-from-package
```

## File: lib/features/vocabulary/data/models/vocabulary_model.dart
```dart
// lib/features/vocabulary/data/models/vocabulary_model.dart
import 'vocabulary.dart';

class VocabularyModel {
  final int id;
  final int categoryId;
  final String kanji;
  final String hiragana;
  final String romaji;
  final String wordType;
  final String meaningVn;
  final String meaningEn;
  final bool isFavorite;
  final bool isLearned;

  VocabularyModel({
    required this.id,
    required this.categoryId,
    required this.kanji,
    required this.hiragana,
    required this.romaji,
    required this.wordType,
    required this.meaningVn,
    required this.meaningEn,
    required this.isFavorite,
    required this.isLearned,
  });

  factory VocabularyModel.fromJson(Map<String, dynamic> json) {
    return VocabularyModel(
      id: json['id'],
      categoryId: json['category_id'],
      kanji: json['kanji'] ?? '',
      hiragana: json['hiragana'] ?? '',
      romaji: json['romaji'] ?? '',
      wordType: json['word_type'] ?? '',
      meaningVn: json['meaning_vn'] ?? '',
      meaningEn: json['meaning_en'] ?? '',
      isFavorite: json['is_favorite'] ?? false,
      isLearned: json['is_learned'] ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'category_id': categoryId,
      'kanji': kanji,
      'hiragana': hiragana,
      'romaji': romaji,
      'word_type': wordType,
      'meaning_vn': meaningVn,
      'meaning_en': meaningEn,
      'is_favorite': isFavorite,
      'is_learned': isLearned,
    };
  }

  Vocabulary toEntity() {
    return Vocabulary(
      id: id,
      categoryId: categoryId,
      kanji: kanji,
      hiragana: hiragana,
      romaji: romaji,
      meaningEn: meaningEn,
      meaningVn: meaningVn,
      isFavorite: isFavorite,
      isLearned: isLearned,
    );
  }
}
```

## File: lib/features/vocabulary/data/repositories/vocabulary_repository.dart
```dart
// lib/features/vocabulary/data/repositories/vocabulary_repository.dart

import '../datasources/vocabulary_remote_datasource.dart';
import '../models/vocabulary_model.dart';
import '../models/vocabulary.dart';

class VocabularyRepository {
  final VocabularyRemoteDatasource datasource;

  VocabularyRepository(this.datasource);

  Future<List<Vocabulary>> getAll() async {
    final models = await datasource.getAll();
    return models.map((e) => e.toEntity()).toList();
  }

  Future<void> add(VocabularyModel vocab) {
    return datasource.insert(vocab);
  }

  Future<void> update(int id, VocabularyModel vocab) {
    return datasource.update(id, vocab);
  }

  Future<void> delete(int id) {
    return datasource.delete(id);
  }

  Future<void> toggleFavorite(int id, bool value) async {
    await datasource.updateFavorite(id, value);
  }

  Future<void> toggleLearned(int id, bool value) async {
    await datasource.updateLearned(id, value);
  }
}
```

## File: lib/main.dart
```dart
import 'package:flutter/material.dart';
import 'package:nihongo_app/features/vocabulary/presentation/pages/vocabulary_list_page.dart';
import 'core/services/supabase_service.dart';
import 'features/auth/presentation/auth_gate.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await SupabaseService.init();
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Japanese Learning App',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        useMaterial3: true,
      ),
      home: const VocabularyListPage(),
    );
  }
}
```

## File: lib/features/vocabulary/presentation/pages/vocabulary_form_page.dart
```dart
import 'package:flutter/material.dart';
import 'package:nihongo_app/features/vocabulary/data/models/vocabulary.dart';

import '../../data/models/vocabulary_model.dart';
import '../../data/repositories/vocabulary_repository.dart';
import '../../data/datasources/vocabulary_remote_datasource.dart';
import '../../data/models/category_model.dart';
import '../../data/datasources/category_remote_datasource.dart';

class VocabularyFormPage extends StatefulWidget {
  final Vocabulary? vocab; // null = create, c√≥ = edit

  const VocabularyFormPage({super.key, this.vocab});

  @override
  State<VocabularyFormPage> createState() => _VocabularyFormPageState();
}

class _VocabularyFormPageState extends State<VocabularyFormPage> {
  final _formKey = GlobalKey<FormState>();
  List<CategoryModel> categories = [];
  int? selectedCategoryId;
  late final VocabularyRepository repository;

  final kanjiCtrl = TextEditingController();
  final hiraCtrl = TextEditingController();
  final romajiCtrl = TextEditingController();
  final meaningEnCtrl = TextEditingController();
  final meaningVnCtrl = TextEditingController();

  @override
  void initState() {
    super.initState();
    repository = VocabularyRepository(VocabularyRemoteDatasource());

    if (widget.vocab != null) {
      kanjiCtrl.text = widget.vocab!.kanji;
      hiraCtrl.text = widget.vocab!.hiragana;
      romajiCtrl.text = widget.vocab!.romaji;
      meaningEnCtrl.text = widget.vocab!.meaningEn;
      meaningVnCtrl.text = widget.vocab!.meaningVn;
    }

    CategoryRemoteDatasource().getVocabularyCategories().then((value) {
      setState(() {
        categories = value;

        if (widget.vocab != null) {
          selectedCategoryId = widget.vocab!.categoryId;
        } else if (categories.isNotEmpty) {
          selectedCategoryId = categories.first.id;
        }
      });
    });
  }

  Future<void> _save() async {
    if (!_formKey.currentState!.validate()) return;

    final vocab = VocabularyModel(
      id: widget.vocab?.id ?? 0,
      categoryId: selectedCategoryId!,
      kanji: kanjiCtrl.text,
      hiragana: hiraCtrl.text,
      romaji: romajiCtrl.text,
      wordType: '',
      meaningEn: meaningEnCtrl.text,
      meaningVn: meaningVnCtrl.text,
      isFavorite: false,
      isLearned: false,
    );

    if (widget.vocab == null) {
      await repository.add(vocab);
    } else {
      await repository.update(widget.vocab!.id, vocab);
    }

    if (mounted) Navigator.pop(context, true);
  }

  @override
  Widget build(BuildContext context) {
    final isEdit = widget.vocab != null;

    return Scaffold(
      appBar: AppBar(
        title: Text(isEdit ? 'Edit Vocabulary' : 'Add Vocabulary'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: ListView(
            children: [
              DropdownButtonFormField<int>(
                value: selectedCategoryId,
                decoration: const InputDecoration(labelText: 'Category'),
                items:
                    categories
                        .map(
                          (c) => DropdownMenuItem(
                            value: c.id,
                            child: Text(c.title),
                          ),
                        )
                        .toList(),
                onChanged: (value) {
                  setState(() {
                    selectedCategoryId = value;
                  });
                },
                validator: (v) => v == null ? 'Select category' : null,
              ),

              TextFormField(
                controller: kanjiCtrl,
                decoration: const InputDecoration(labelText: 'Kanji'),
              ),
              TextFormField(
                controller: hiraCtrl,
                decoration: const InputDecoration(labelText: 'Hiragana'),
                validator: (v) => v == null || v.isEmpty ? 'Required' : null,
              ),
              TextFormField(
                controller: romajiCtrl,
                decoration: const InputDecoration(labelText: 'Romaji'),
              ),
              TextFormField(
                controller: meaningEnCtrl,
                decoration: const InputDecoration(labelText: 'Meaning (EN)'),
              ),
              TextFormField(
                controller: meaningVnCtrl,
                decoration: const InputDecoration(labelText: 'Meaning (VN)'),
              ),
              const SizedBox(height: 20),
              ElevatedButton(onPressed: _save, child: const Text('Save')),
            ],
          ),
        ),
      ),
    );
  }
}
```

## File: lib/features/features.txt
```
1Ô∏è‚É£ M√¨nh ch·ªâ b·∫°n Delete (long press)
2Ô∏è‚É£ G·∫Øn Category dropdown cho vocabulary
3Ô∏è‚É£ Refactor l·∫°i list cho search

2Ô∏è‚É£ Th√™m search + filter vocabulary
3Ô∏è‚É£ Chu·∫©n b·ªã copy feature n√†y sang Grammar / Kanji

1Ô∏è‚É£ ‚≠ê Favorite vocabulary
2Ô∏è‚É£ üìä Learned / Progress
3Ô∏è‚É£ üîÅ Random quiz
4Ô∏è‚É£ üß† SRS (√¥n t·∫≠p th√¥ng minh)

2Ô∏è‚É£ üìä Learned / Progress
    1Ô∏è‚É£ Progress bar (JLPT style)
    2Ô∏è‚É£ Filter Learned / Unlearned
    3Ô∏è‚É£ Sort A‚ÄìZ / Favorite first
    4Ô∏è‚É£ Quiz t·ª´ vocab ƒë√£ learned

3Ô∏è‚É£ üîÅ Random Quiz / Test
    1Ô∏è‚É£ Quiz theo Category / JLPT
    2Ô∏è‚É£ Ghi ƒëi·ªÉm + streak
    3Ô∏è‚É£ Sai th√¨ auto set learned = false
    4Ô∏è‚É£ Flashcard (l·∫≠t th·∫ª)
    5Ô∏è‚É£ Grammar / Kanji quiz d√πng l·∫°i y chang
    
4Ô∏è‚É£ üß† SRS ‚Äì √¥n t·∫≠p th√¥ng minh


Auth
    1Ô∏è‚É£ Login email + Google (Flutter + Supabase)
        1Ô∏è‚É£ ·∫®n / hi·ªán CRUD theo role (admin / learner)
        2Ô∏è‚É£ G·∫Øn learned + favorite theo user (c·ª±c quan tr·ªçng)
        3Ô∏è‚É£ B·∫≠t RLS an to√†n
        4Ô∏è‚É£ Sync progress ƒëa thi·∫øt b·ªã
        4Ô∏è‚É£ Multi-device sync
    2Ô∏è‚É£ G·∫Øn progress v√†o user (refactor learned/favorite)
    3Ô∏è‚É£ Admin / Learner UI kh√°c nhau
    4Ô∏è‚É£ Offline-first (local cache)

local
1Ô∏è‚É£ T√°ch learned/favorite: guest vs user
2Ô∏è‚É£ Local cache cho guest (Hive / SharedPreferences)
        üîπ C√°ch A ‚Äì SharedPreferences (KHUY√äN D√ôNG B√ÇY GI·ªú)
        ‚úî D·ªÖ
        ‚úî Nh·∫π
        ‚úî Ph√π h·ª£p learned / favorite / progress
        ‚ùå Kh√¥ng ph√π h·ª£p data l·ªõn

        üëâ D√πng cho guest mode (chu·∫©n)

        üîπ C√°ch B ‚Äì SQLite / Drift / Floor

        ‚úî Data l·ªõn
        ‚úî Query m·∫°nh
        ‚ùå Code nhi·ªÅu
        ‚ùå D·ªÖ ng·ª£p l√∫c ƒë·∫ßu

        üëâ D√πng khi:

        Offline full vocab

        T·ª´ ƒëi·ªÉn l·ªõn

        üîπ C√°ch C ‚Äì Hive / Isar

        ‚úî Nhanh
        ‚úî NoSQL
        ‚úî App l·ªõn

        üëâ D√πng sau n√†y
3Ô∏è‚É£ Sync local ‚Üí cloud khi login
4Ô∏è‚É£ RLS theo user


Import excel d·ªØ li·ªáu
```

## File: lib/features/vocabulary/presentation/pages/vocabulary_list_page.dart
```dart
import 'package:flutter/material.dart';
import 'package:nihongo_app/features/auth/presentation/login_page.dart';
import 'package:nihongo_app/features/vocabulary/data/datasources/category_remote_datasource.dart';
import 'package:nihongo_app/features/vocabulary/data/models/category_model.dart';
import 'package:nihongo_app/features/vocabulary/presentation/pages/vocabulary_quiz_page.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:nihongo_app/core/ultis/auth_helper.dart';

import '../../data/datasources/vocabulary_remote_datasource.dart';
import '../../data/repositories/vocabulary_repository.dart';
// import '../../data/models/vocabulary_model.dart';
import 'vocabulary_form_page.dart';
import '../../data/models/vocabulary.dart';

class VocabularyListPage extends StatefulWidget {
  const VocabularyListPage({super.key});

  @override
  State<VocabularyListPage> createState() => _VocabularyListPageState();
}

class _VocabularyListPageState extends State<VocabularyListPage> {
  late final VocabularyRepository repository;
  List<Vocabulary> allList = [];
  List<Vocabulary> filteredList = [];
  List<CategoryModel> categories = [];

  bool isLoading = true;
  int? selectedCategoryId;
  String searchText = '';

  @override
  void initState() {
    super.initState();
    CategoryRemoteDatasource().getVocabularyCategories().then((value) {
      setState(() {
        categories = value;
      });
    });
    repository = VocabularyRepository(VocabularyRemoteDatasource());
    loadVocabulary();
  }

  void showLoginHint() {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: const Text('Login to sync your progress'),
        action: SnackBarAction(
          label: 'Login',
          onPressed: () {
            Navigator.push(
              context,
              MaterialPageRoute(builder: (_) => const LoginPage()),
            );
          },
        ),
      ),
    );
  }

  Future<void> loadVocabulary() async {
    setState(() => isLoading = true);

    final data = await repository.getAll();

    setState(() {
      allList = data;
      applyFilter();
      isLoading = false;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Vocabulary'),
        actions: [
          Builder(
            builder: (context) {
              final user = Supabase.instance.client.auth.currentUser;

              if (user == null) {
                return IconButton(
                  icon: const Icon(Icons.login),
                  tooltip: 'Login to sync',
                  onPressed: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(builder: (_) => const LoginPage()),
                    );
                  },
                );
              } else {
                return IconButton(
                  icon: const Icon(Icons.logout),
                  onPressed: () async {
                    await Supabase.instance.client.auth.signOut();
                    ScaffoldMessenger.of(
                      context,
                    ).showSnackBar(const SnackBar(content: Text('Logged out')));
                  },
                );
              }
            },
          ),
          IconButton(
            icon: const Icon(Icons.quiz),
            onPressed: () {
              // ch·∫∑n khi √≠t vocab
              if (allList.length < 4) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Need at least 4 vocabularies')),
                );
                return;
              }

              Navigator.push(
                context,
                MaterialPageRoute(
                  builder:
                      (_) => VocabularyQuizPage(
                        vocabList: allList.where((v) => !v.isLearned).toList(),
                      ),
                ),
              );
            },
          ),
          IconButton(
            icon: const Icon(Icons.logout),
            onPressed: () async {
              await Supabase.instance.client.auth.signOut();
            },
          ),
        ],
      ),

      body: Column(
        children: [
          Padding(
            padding: const EdgeInsets.all(8),
            child: TextField(
              decoration: const InputDecoration(
                prefixIcon: Icon(Icons.search),
                hintText: 'Search vocabulary...',
                border: OutlineInputBorder(),
              ),
              onChanged: (value) {
                searchText = value;
                applyFilter();
              },
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8),
            child: DropdownButtonFormField<int>(
              value: selectedCategoryId,
              hint: const Text('Filter by category'),
              items:
                  categories
                      .map(
                        (c) =>
                            DropdownMenuItem(value: c.id, child: Text(c.title)),
                      )
                      .toList(),
              onChanged: (value) {
                selectedCategoryId = value;
                applyFilter();
              },
            ),
          ),

          Expanded(
            child:
                isLoading
                    ? const Center(child: CircularProgressIndicator())
                    : filteredList.isEmpty
                    ? const Center(child: Text('No vocabulary found'))
                    : ListView.builder(
                      itemCount: filteredList.length,
                      itemBuilder: (context, index) {
                        final v = filteredList[index];
                        return ListTile(
                          leading: IconButton(
                            icon: Icon(
                              v.isLearned
                                  ? Icons.check_circle
                                  : Icons.radio_button_unchecked,
                              color: v.isLearned ? Colors.green : Colors.grey,
                            ),
                            onPressed: () async {
                              if (AuthHelper.isGuest) {
                                showLoginHint();
                                return;
                              }

                              await repository.toggleLearned(
                                v.id,
                                !v.isLearned,
                              );
                              loadVocabulary();
                            },
                          ),
                          title: Text(
                            v.kanji.isNotEmpty ? v.kanji : v.hiragana,
                          ),
                          subtitle: Text('${v.meaningEn} / ${v.meaningVn}'),
                          trailing: IconButton(
                            icon: Icon(
                              v.isFavorite ? Icons.star : Icons.star_border,
                              color: v.isFavorite ? Colors.amber : null,
                            ),
                            onPressed: () async {
                              await repository.toggleFavorite(
                                v.id,
                                !v.isFavorite,
                              );
                              loadVocabulary();
                            },
                          ),

                          onTap: () async {
                            final result = await Navigator.push(
                              context,
                              MaterialPageRoute(
                                builder: (_) => VocabularyFormPage(vocab: v),
                              ),
                            );
                            if (result == true) {
                              loadVocabulary();
                            }
                          },
                          onLongPress: () async {
                            final ok = await showDialog<bool>(
                              context: context,
                              builder:
                                  (_) => AlertDialog(
                                    title: const Text('Delete'),
                                    content: const Text(
                                      'Delete this vocabulary?',
                                    ),
                                    actions: [
                                      TextButton(
                                        onPressed:
                                            () => Navigator.pop(context, false),
                                        child: const Text('Cancel'),
                                      ),
                                      TextButton(
                                        onPressed:
                                            () => Navigator.pop(context, true),
                                        child: const Text('Delete'),
                                      ),
                                    ],
                                  ),
                            );
                            if (ok == true) {
                              await repository.delete(v.id);
                              loadVocabulary();
                            }
                          },
                        );
                      },
                    ),
          ),
        ],
      ),

      floatingActionButton: FloatingActionButton(
        onPressed: () async {
          final result = await Navigator.push(
            context,
            MaterialPageRoute(builder: (_) => const VocabularyFormPage()),
          );

          if (result == true) {
            loadVocabulary();
          }
        },
        child: const Icon(Icons.add),
      ),
    );
  }

  void applyFilter() {
    filteredList =
        allList.where((v) {
          final matchCategory =
              selectedCategoryId == null || v.categoryId == selectedCategoryId;

          final text = searchText.toLowerCase();

          final matchSearch =
              text.isEmpty ||
              v.kanji.toLowerCase().contains(text) ||
              v.hiragana.toLowerCase().contains(text) ||
              v.romaji.toLowerCase().contains(text) ||
              v.meaningEn.toLowerCase().contains(text) ||
              v.meaningVn.toLowerCase().contains(text);

          return matchCategory && matchSearch;
        }).toList();

    setState(() {});
  }
}
```
