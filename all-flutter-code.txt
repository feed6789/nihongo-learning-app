This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: lib/**/*, pubspec.yaml, analysis_options.yaml
- Files matching these patterns are excluded: **/build/**, **/.dart_tool/**, **/.git/**, **/android/**, **/ios/**, **/web/**, **/linux/**, **/macos/**, **/windows/**, **/*.png, **/*.jpg
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
analysis_options.yaml
lib/core/constants/app_strings.dart
lib/core/constants/supabase_constants.dart
lib/core/local_db/app_database.dart
lib/core/local_db/app_database.g.dart
lib/core/local_db/db_instance.dart
lib/core/local_db/tables/local_vocab_progress.dart
lib/core/services/supabase_service.dart
lib/core/ultis/auth_helper.dart
lib/core/ultis/logger.dart
lib/features/auth/data/auth_service.dart
lib/features/auth/presentation/auth_gate.dart
lib/features/auth/presentation/login_page.dart
lib/features/auth/presentation/register_page.dart
lib/features/features.txt
lib/features/vocabulary/data/datasources/category_remote_datasource.dart
lib/features/vocabulary/data/datasources/vocabulary_local_datasource.dart
lib/features/vocabulary/data/datasources/vocabulary_remote_datasource.dart
lib/features/vocabulary/data/models/category_model.dart
lib/features/vocabulary/data/models/vocabulary_model.dart
lib/features/vocabulary/data/models/vocabulary.dart
lib/features/vocabulary/data/repositories/vocabulary_repository.dart
lib/features/vocabulary/presentation/pages/vocabulary_detail_page.dart
lib/features/vocabulary/presentation/pages/vocabulary_form_page.dart
lib/features/vocabulary/presentation/pages/vocabulary_list_page.dart
lib/features/vocabulary/presentation/pages/vocabulary_quiz_page.dart
lib/features/vocabulary/presentation/widgets/vocabulary_card.dart
lib/features/vocabulary/vocabulary_routes.dart
lib/main.dart
lib/shared/themes/app_theme.dart
lib/shared/widgets/app_button.dart
pubspec.yaml
```

# Files

## File: analysis_options.yaml
```yaml
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options
```

## File: lib/core/constants/app_strings.dart
```dart

```

## File: lib/core/constants/supabase_constants.dart
```dart

```

## File: lib/core/local_db/app_database.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'app_database.dart';

// ignore_for_file: type=lint
class $VocabularyTableTable extends VocabularyTable
    with TableInfo<$VocabularyTableTable, VocabularyTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $VocabularyTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _categoryIdMeta = const VerificationMeta(
    'categoryId',
  );
  @override
  late final GeneratedColumn<int> categoryId = GeneratedColumn<int>(
    'category_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _kanjiMeta = const VerificationMeta('kanji');
  @override
  late final GeneratedColumn<String> kanji = GeneratedColumn<String>(
    'kanji',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant(''),
  );
  static const VerificationMeta _hiraganaMeta = const VerificationMeta(
    'hiragana',
  );
  @override
  late final GeneratedColumn<String> hiragana = GeneratedColumn<String>(
    'hiragana',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant(''),
  );
  static const VerificationMeta _romajiMeta = const VerificationMeta('romaji');
  @override
  late final GeneratedColumn<String> romaji = GeneratedColumn<String>(
    'romaji',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant(''),
  );
  static const VerificationMeta _meaningVnMeta = const VerificationMeta(
    'meaningVn',
  );
  @override
  late final GeneratedColumn<String> meaningVn = GeneratedColumn<String>(
    'meaning_vn',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant(''),
  );
  static const VerificationMeta _meaningEnMeta = const VerificationMeta(
    'meaningEn',
  );
  @override
  late final GeneratedColumn<String> meaningEn = GeneratedColumn<String>(
    'meaning_en',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant(''),
  );
  static const VerificationMeta _isFavoriteMeta = const VerificationMeta(
    'isFavorite',
  );
  @override
  late final GeneratedColumn<bool> isFavorite = GeneratedColumn<bool>(
    'is_favorite',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_favorite" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _isLearnedMeta = const VerificationMeta(
    'isLearned',
  );
  @override
  late final GeneratedColumn<bool> isLearned = GeneratedColumn<bool>(
    'is_learned',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_learned" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    categoryId,
    kanji,
    hiragana,
    romaji,
    meaningVn,
    meaningEn,
    isFavorite,
    isLearned,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'vocabulary_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<VocabularyTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('category_id')) {
      context.handle(
        _categoryIdMeta,
        categoryId.isAcceptableOrUnknown(data['category_id']!, _categoryIdMeta),
      );
    } else if (isInserting) {
      context.missing(_categoryIdMeta);
    }
    if (data.containsKey('kanji')) {
      context.handle(
        _kanjiMeta,
        kanji.isAcceptableOrUnknown(data['kanji']!, _kanjiMeta),
      );
    }
    if (data.containsKey('hiragana')) {
      context.handle(
        _hiraganaMeta,
        hiragana.isAcceptableOrUnknown(data['hiragana']!, _hiraganaMeta),
      );
    }
    if (data.containsKey('romaji')) {
      context.handle(
        _romajiMeta,
        romaji.isAcceptableOrUnknown(data['romaji']!, _romajiMeta),
      );
    }
    if (data.containsKey('meaning_vn')) {
      context.handle(
        _meaningVnMeta,
        meaningVn.isAcceptableOrUnknown(data['meaning_vn']!, _meaningVnMeta),
      );
    }
    if (data.containsKey('meaning_en')) {
      context.handle(
        _meaningEnMeta,
        meaningEn.isAcceptableOrUnknown(data['meaning_en']!, _meaningEnMeta),
      );
    }
    if (data.containsKey('is_favorite')) {
      context.handle(
        _isFavoriteMeta,
        isFavorite.isAcceptableOrUnknown(data['is_favorite']!, _isFavoriteMeta),
      );
    }
    if (data.containsKey('is_learned')) {
      context.handle(
        _isLearnedMeta,
        isLearned.isAcceptableOrUnknown(data['is_learned']!, _isLearnedMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  VocabularyTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return VocabularyTableData(
      id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}id'],
          )!,
      categoryId:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}category_id'],
          )!,
      kanji:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}kanji'],
          )!,
      hiragana:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}hiragana'],
          )!,
      romaji:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}romaji'],
          )!,
      meaningVn:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}meaning_vn'],
          )!,
      meaningEn:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}meaning_en'],
          )!,
      isFavorite:
          attachedDatabase.typeMapping.read(
            DriftSqlType.bool,
            data['${effectivePrefix}is_favorite'],
          )!,
      isLearned:
          attachedDatabase.typeMapping.read(
            DriftSqlType.bool,
            data['${effectivePrefix}is_learned'],
          )!,
    );
  }

  @override
  $VocabularyTableTable createAlias(String alias) {
    return $VocabularyTableTable(attachedDatabase, alias);
  }
}

class VocabularyTableData extends DataClass
    implements Insertable<VocabularyTableData> {
  final int id;
  final int categoryId;
  final String kanji;
  final String hiragana;
  final String romaji;
  final String meaningVn;
  final String meaningEn;
  final bool isFavorite;
  final bool isLearned;
  const VocabularyTableData({
    required this.id,
    required this.categoryId,
    required this.kanji,
    required this.hiragana,
    required this.romaji,
    required this.meaningVn,
    required this.meaningEn,
    required this.isFavorite,
    required this.isLearned,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['category_id'] = Variable<int>(categoryId);
    map['kanji'] = Variable<String>(kanji);
    map['hiragana'] = Variable<String>(hiragana);
    map['romaji'] = Variable<String>(romaji);
    map['meaning_vn'] = Variable<String>(meaningVn);
    map['meaning_en'] = Variable<String>(meaningEn);
    map['is_favorite'] = Variable<bool>(isFavorite);
    map['is_learned'] = Variable<bool>(isLearned);
    return map;
  }

  VocabularyTableCompanion toCompanion(bool nullToAbsent) {
    return VocabularyTableCompanion(
      id: Value(id),
      categoryId: Value(categoryId),
      kanji: Value(kanji),
      hiragana: Value(hiragana),
      romaji: Value(romaji),
      meaningVn: Value(meaningVn),
      meaningEn: Value(meaningEn),
      isFavorite: Value(isFavorite),
      isLearned: Value(isLearned),
    );
  }

  factory VocabularyTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return VocabularyTableData(
      id: serializer.fromJson<int>(json['id']),
      categoryId: serializer.fromJson<int>(json['categoryId']),
      kanji: serializer.fromJson<String>(json['kanji']),
      hiragana: serializer.fromJson<String>(json['hiragana']),
      romaji: serializer.fromJson<String>(json['romaji']),
      meaningVn: serializer.fromJson<String>(json['meaningVn']),
      meaningEn: serializer.fromJson<String>(json['meaningEn']),
      isFavorite: serializer.fromJson<bool>(json['isFavorite']),
      isLearned: serializer.fromJson<bool>(json['isLearned']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'categoryId': serializer.toJson<int>(categoryId),
      'kanji': serializer.toJson<String>(kanji),
      'hiragana': serializer.toJson<String>(hiragana),
      'romaji': serializer.toJson<String>(romaji),
      'meaningVn': serializer.toJson<String>(meaningVn),
      'meaningEn': serializer.toJson<String>(meaningEn),
      'isFavorite': serializer.toJson<bool>(isFavorite),
      'isLearned': serializer.toJson<bool>(isLearned),
    };
  }

  VocabularyTableData copyWith({
    int? id,
    int? categoryId,
    String? kanji,
    String? hiragana,
    String? romaji,
    String? meaningVn,
    String? meaningEn,
    bool? isFavorite,
    bool? isLearned,
  }) => VocabularyTableData(
    id: id ?? this.id,
    categoryId: categoryId ?? this.categoryId,
    kanji: kanji ?? this.kanji,
    hiragana: hiragana ?? this.hiragana,
    romaji: romaji ?? this.romaji,
    meaningVn: meaningVn ?? this.meaningVn,
    meaningEn: meaningEn ?? this.meaningEn,
    isFavorite: isFavorite ?? this.isFavorite,
    isLearned: isLearned ?? this.isLearned,
  );
  VocabularyTableData copyWithCompanion(VocabularyTableCompanion data) {
    return VocabularyTableData(
      id: data.id.present ? data.id.value : this.id,
      categoryId:
          data.categoryId.present ? data.categoryId.value : this.categoryId,
      kanji: data.kanji.present ? data.kanji.value : this.kanji,
      hiragana: data.hiragana.present ? data.hiragana.value : this.hiragana,
      romaji: data.romaji.present ? data.romaji.value : this.romaji,
      meaningVn: data.meaningVn.present ? data.meaningVn.value : this.meaningVn,
      meaningEn: data.meaningEn.present ? data.meaningEn.value : this.meaningEn,
      isFavorite:
          data.isFavorite.present ? data.isFavorite.value : this.isFavorite,
      isLearned: data.isLearned.present ? data.isLearned.value : this.isLearned,
    );
  }

  @override
  String toString() {
    return (StringBuffer('VocabularyTableData(')
          ..write('id: $id, ')
          ..write('categoryId: $categoryId, ')
          ..write('kanji: $kanji, ')
          ..write('hiragana: $hiragana, ')
          ..write('romaji: $romaji, ')
          ..write('meaningVn: $meaningVn, ')
          ..write('meaningEn: $meaningEn, ')
          ..write('isFavorite: $isFavorite, ')
          ..write('isLearned: $isLearned')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    categoryId,
    kanji,
    hiragana,
    romaji,
    meaningVn,
    meaningEn,
    isFavorite,
    isLearned,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is VocabularyTableData &&
          other.id == this.id &&
          other.categoryId == this.categoryId &&
          other.kanji == this.kanji &&
          other.hiragana == this.hiragana &&
          other.romaji == this.romaji &&
          other.meaningVn == this.meaningVn &&
          other.meaningEn == this.meaningEn &&
          other.isFavorite == this.isFavorite &&
          other.isLearned == this.isLearned);
}

class VocabularyTableCompanion extends UpdateCompanion<VocabularyTableData> {
  final Value<int> id;
  final Value<int> categoryId;
  final Value<String> kanji;
  final Value<String> hiragana;
  final Value<String> romaji;
  final Value<String> meaningVn;
  final Value<String> meaningEn;
  final Value<bool> isFavorite;
  final Value<bool> isLearned;
  const VocabularyTableCompanion({
    this.id = const Value.absent(),
    this.categoryId = const Value.absent(),
    this.kanji = const Value.absent(),
    this.hiragana = const Value.absent(),
    this.romaji = const Value.absent(),
    this.meaningVn = const Value.absent(),
    this.meaningEn = const Value.absent(),
    this.isFavorite = const Value.absent(),
    this.isLearned = const Value.absent(),
  });
  VocabularyTableCompanion.insert({
    this.id = const Value.absent(),
    required int categoryId,
    this.kanji = const Value.absent(),
    this.hiragana = const Value.absent(),
    this.romaji = const Value.absent(),
    this.meaningVn = const Value.absent(),
    this.meaningEn = const Value.absent(),
    this.isFavorite = const Value.absent(),
    this.isLearned = const Value.absent(),
  }) : categoryId = Value(categoryId);
  static Insertable<VocabularyTableData> custom({
    Expression<int>? id,
    Expression<int>? categoryId,
    Expression<String>? kanji,
    Expression<String>? hiragana,
    Expression<String>? romaji,
    Expression<String>? meaningVn,
    Expression<String>? meaningEn,
    Expression<bool>? isFavorite,
    Expression<bool>? isLearned,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (categoryId != null) 'category_id': categoryId,
      if (kanji != null) 'kanji': kanji,
      if (hiragana != null) 'hiragana': hiragana,
      if (romaji != null) 'romaji': romaji,
      if (meaningVn != null) 'meaning_vn': meaningVn,
      if (meaningEn != null) 'meaning_en': meaningEn,
      if (isFavorite != null) 'is_favorite': isFavorite,
      if (isLearned != null) 'is_learned': isLearned,
    });
  }

  VocabularyTableCompanion copyWith({
    Value<int>? id,
    Value<int>? categoryId,
    Value<String>? kanji,
    Value<String>? hiragana,
    Value<String>? romaji,
    Value<String>? meaningVn,
    Value<String>? meaningEn,
    Value<bool>? isFavorite,
    Value<bool>? isLearned,
  }) {
    return VocabularyTableCompanion(
      id: id ?? this.id,
      categoryId: categoryId ?? this.categoryId,
      kanji: kanji ?? this.kanji,
      hiragana: hiragana ?? this.hiragana,
      romaji: romaji ?? this.romaji,
      meaningVn: meaningVn ?? this.meaningVn,
      meaningEn: meaningEn ?? this.meaningEn,
      isFavorite: isFavorite ?? this.isFavorite,
      isLearned: isLearned ?? this.isLearned,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (categoryId.present) {
      map['category_id'] = Variable<int>(categoryId.value);
    }
    if (kanji.present) {
      map['kanji'] = Variable<String>(kanji.value);
    }
    if (hiragana.present) {
      map['hiragana'] = Variable<String>(hiragana.value);
    }
    if (romaji.present) {
      map['romaji'] = Variable<String>(romaji.value);
    }
    if (meaningVn.present) {
      map['meaning_vn'] = Variable<String>(meaningVn.value);
    }
    if (meaningEn.present) {
      map['meaning_en'] = Variable<String>(meaningEn.value);
    }
    if (isFavorite.present) {
      map['is_favorite'] = Variable<bool>(isFavorite.value);
    }
    if (isLearned.present) {
      map['is_learned'] = Variable<bool>(isLearned.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('VocabularyTableCompanion(')
          ..write('id: $id, ')
          ..write('categoryId: $categoryId, ')
          ..write('kanji: $kanji, ')
          ..write('hiragana: $hiragana, ')
          ..write('romaji: $romaji, ')
          ..write('meaningVn: $meaningVn, ')
          ..write('meaningEn: $meaningEn, ')
          ..write('isFavorite: $isFavorite, ')
          ..write('isLearned: $isLearned')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $VocabularyTableTable vocabularyTable = $VocabularyTableTable(
    this,
  );
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [vocabularyTable];
}

typedef $$VocabularyTableTableCreateCompanionBuilder =
    VocabularyTableCompanion Function({
      Value<int> id,
      required int categoryId,
      Value<String> kanji,
      Value<String> hiragana,
      Value<String> romaji,
      Value<String> meaningVn,
      Value<String> meaningEn,
      Value<bool> isFavorite,
      Value<bool> isLearned,
    });
typedef $$VocabularyTableTableUpdateCompanionBuilder =
    VocabularyTableCompanion Function({
      Value<int> id,
      Value<int> categoryId,
      Value<String> kanji,
      Value<String> hiragana,
      Value<String> romaji,
      Value<String> meaningVn,
      Value<String> meaningEn,
      Value<bool> isFavorite,
      Value<bool> isLearned,
    });

class $$VocabularyTableTableFilterComposer
    extends Composer<_$AppDatabase, $VocabularyTableTable> {
  $$VocabularyTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get categoryId => $composableBuilder(
    column: $table.categoryId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get kanji => $composableBuilder(
    column: $table.kanji,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get hiragana => $composableBuilder(
    column: $table.hiragana,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get romaji => $composableBuilder(
    column: $table.romaji,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get meaningVn => $composableBuilder(
    column: $table.meaningVn,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get meaningEn => $composableBuilder(
    column: $table.meaningEn,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isFavorite => $composableBuilder(
    column: $table.isFavorite,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isLearned => $composableBuilder(
    column: $table.isLearned,
    builder: (column) => ColumnFilters(column),
  );
}

class $$VocabularyTableTableOrderingComposer
    extends Composer<_$AppDatabase, $VocabularyTableTable> {
  $$VocabularyTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get categoryId => $composableBuilder(
    column: $table.categoryId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get kanji => $composableBuilder(
    column: $table.kanji,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get hiragana => $composableBuilder(
    column: $table.hiragana,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get romaji => $composableBuilder(
    column: $table.romaji,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get meaningVn => $composableBuilder(
    column: $table.meaningVn,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get meaningEn => $composableBuilder(
    column: $table.meaningEn,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isFavorite => $composableBuilder(
    column: $table.isFavorite,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isLearned => $composableBuilder(
    column: $table.isLearned,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$VocabularyTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $VocabularyTableTable> {
  $$VocabularyTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get categoryId => $composableBuilder(
    column: $table.categoryId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get kanji =>
      $composableBuilder(column: $table.kanji, builder: (column) => column);

  GeneratedColumn<String> get hiragana =>
      $composableBuilder(column: $table.hiragana, builder: (column) => column);

  GeneratedColumn<String> get romaji =>
      $composableBuilder(column: $table.romaji, builder: (column) => column);

  GeneratedColumn<String> get meaningVn =>
      $composableBuilder(column: $table.meaningVn, builder: (column) => column);

  GeneratedColumn<String> get meaningEn =>
      $composableBuilder(column: $table.meaningEn, builder: (column) => column);

  GeneratedColumn<bool> get isFavorite => $composableBuilder(
    column: $table.isFavorite,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isLearned =>
      $composableBuilder(column: $table.isLearned, builder: (column) => column);
}

class $$VocabularyTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $VocabularyTableTable,
          VocabularyTableData,
          $$VocabularyTableTableFilterComposer,
          $$VocabularyTableTableOrderingComposer,
          $$VocabularyTableTableAnnotationComposer,
          $$VocabularyTableTableCreateCompanionBuilder,
          $$VocabularyTableTableUpdateCompanionBuilder,
          (
            VocabularyTableData,
            BaseReferences<
              _$AppDatabase,
              $VocabularyTableTable,
              VocabularyTableData
            >,
          ),
          VocabularyTableData,
          PrefetchHooks Function()
        > {
  $$VocabularyTableTableTableManager(
    _$AppDatabase db,
    $VocabularyTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () =>
                  $$VocabularyTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$VocabularyTableTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer:
              () => $$VocabularyTableTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<int> categoryId = const Value.absent(),
                Value<String> kanji = const Value.absent(),
                Value<String> hiragana = const Value.absent(),
                Value<String> romaji = const Value.absent(),
                Value<String> meaningVn = const Value.absent(),
                Value<String> meaningEn = const Value.absent(),
                Value<bool> isFavorite = const Value.absent(),
                Value<bool> isLearned = const Value.absent(),
              }) => VocabularyTableCompanion(
                id: id,
                categoryId: categoryId,
                kanji: kanji,
                hiragana: hiragana,
                romaji: romaji,
                meaningVn: meaningVn,
                meaningEn: meaningEn,
                isFavorite: isFavorite,
                isLearned: isLearned,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required int categoryId,
                Value<String> kanji = const Value.absent(),
                Value<String> hiragana = const Value.absent(),
                Value<String> romaji = const Value.absent(),
                Value<String> meaningVn = const Value.absent(),
                Value<String> meaningEn = const Value.absent(),
                Value<bool> isFavorite = const Value.absent(),
                Value<bool> isLearned = const Value.absent(),
              }) => VocabularyTableCompanion.insert(
                id: id,
                categoryId: categoryId,
                kanji: kanji,
                hiragana: hiragana,
                romaji: romaji,
                meaningVn: meaningVn,
                meaningEn: meaningEn,
                isFavorite: isFavorite,
                isLearned: isLearned,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          BaseReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$VocabularyTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $VocabularyTableTable,
      VocabularyTableData,
      $$VocabularyTableTableFilterComposer,
      $$VocabularyTableTableOrderingComposer,
      $$VocabularyTableTableAnnotationComposer,
      $$VocabularyTableTableCreateCompanionBuilder,
      $$VocabularyTableTableUpdateCompanionBuilder,
      (
        VocabularyTableData,
        BaseReferences<
          _$AppDatabase,
          $VocabularyTableTable,
          VocabularyTableData
        >,
      ),
      VocabularyTableData,
      PrefetchHooks Function()
    >;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$VocabularyTableTableTableManager get vocabularyTable =>
      $$VocabularyTableTableTableManager(_db, _db.vocabularyTable);
}
```

## File: lib/core/services/supabase_service.dart
```dart
// lib/core/services/supabase_service.dart

import 'package:supabase_flutter/supabase_flutter.dart';

class SupabaseService {
  static late SupabaseClient client;

  static Future<void> init() async {
    await Supabase.initialize(
      url: 'https://khywpgvcmkwvufquiudy.supabase.co',
      anonKey:
          'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtoeXdwZ3ZjbWt3dnVmcXVpdWR5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk1MDQ2NDAsImV4cCI6MjA4NTA4MDY0MH0.f-no2MOG1fBtbcV73E4z2ALxtWhsbKF4Hz7YwFQQtDA',
    );

    client = Supabase.instance.client;
  }
}
```

## File: lib/core/ultis/auth_helper.dart
```dart
import 'package:supabase_flutter/supabase_flutter.dart';

class AuthHelper {
  static User? get currentUser => Supabase.instance.client.auth.currentUser;

  static bool get isGuest => currentUser == null;
}
```

## File: lib/core/ultis/logger.dart
```dart

```

## File: lib/features/auth/data/auth_service.dart
```dart
import 'package:supabase_flutter/supabase_flutter.dart';

class AuthService {
  final _client = Supabase.instance.client;

  User? get currentUser => _client.auth.currentUser;

  Future<AuthResponse> signInEmail(String email, String password) {
    return _client.auth.signInWithPassword(email: email, password: password);
  }

  Future<AuthResponse> signUpEmail(String email, String password) {
    return _client.auth.signUp(email: email, password: password);
  }

  Future<void> signInWithGoogle() async {
    await _client.auth.signInWithOAuth(
      OAuthProvider.google,
      redirectTo: 'io.supabase.flutter://login-callback',
    );
  }

  Future<void> signOut() async {
    await _client.auth.signOut();
  }
}
```

## File: lib/features/auth/presentation/auth_gate.dart
```dart
import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import '../../vocabulary/presentation/pages/vocabulary_list_page.dart';
import 'login_page.dart';

class AuthGate extends StatelessWidget {
  const AuthGate({super.key});

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<AuthState>(
      stream: Supabase.instance.client.auth.onAuthStateChange,
      builder: (context, snapshot) {
        final session = snapshot.data?.session;

        if (session == null) {
          return const LoginPage();
        } else {
          return const VocabularyListPage();
        }
      },
    );
  }
}
```

## File: lib/features/auth/presentation/login_page.dart
```dart
import 'package:flutter/material.dart';
import '../data/auth_service.dart';

class LoginPage extends StatefulWidget {
  const LoginPage({super.key});

  @override
  State<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends State<LoginPage> {
  final auth = AuthService();
  final emailCtrl = TextEditingController();
  final passCtrl = TextEditingController();
  bool loading = false;

  Future<void> login() async {
    setState(() => loading = true);
    try {
      await auth.signInEmail(emailCtrl.text, passCtrl.text);
    } catch (e) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text(e.toString())));
    }
    setState(() => loading = false);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Login')),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            TextField(
              controller: emailCtrl,
              decoration: const InputDecoration(labelText: 'Email'),
            ),
            TextField(
              controller: passCtrl,
              decoration: const InputDecoration(labelText: 'Password'),
              obscureText: true,
            ),
            const SizedBox(height: 16),

            ElevatedButton(
              onPressed: loading ? null : login,
              child: const Text('Login'),
            ),

            const SizedBox(height: 12),

            ElevatedButton.icon(
              icon: const Icon(Icons.login),
              label: const Text('Login with Google'),
              onPressed: auth.signInWithGoogle,
            ),
          ],
        ),
      ),
    );
  }
}
```

## File: lib/features/auth/presentation/register_page.dart
```dart

```

## File: lib/features/vocabulary/data/datasources/category_remote_datasource.dart
```dart
import '../../../../core/services/supabase_service.dart';
import '../models/category_model.dart';

class CategoryRemoteDatasource {
  final _client = SupabaseService.client;

  Future<List<CategoryModel>> getVocabularyCategories() async {
    final response = await _client
        .from('categories')
        .select()
        .eq('type', 'vocab')
        .order('order_index');

    return (response as List).map((e) => CategoryModel.fromJson(e)).toList();
  }
}
```

## File: lib/features/vocabulary/data/datasources/vocabulary_local_datasource.dart
```dart
import '../../../../core/local_db/db_instance.dart';
import '../../../../core/local_db/app_database.dart';
import '../models/vocabulary_model.dart';

class VocabularyLocalDatasource {
  Future<List<VocabularyModel>> getAll() async {
    final result = await appDatabase.getAll();
    // Convert Drift Data -> VocabularyModel
    return result
        .map(
          (e) => VocabularyModel(
            id: e.id,
            categoryId: e.categoryId,
            kanji: e.kanji,
            hiragana: e.hiragana,
            romaji: e.romaji,
            wordType:
                '', // Local db chưa lưu field này, tạm để rỗng hoặc thêm vào Table sau
            meaningVn: e.meaningVn,
            meaningEn: e.meaningEn,
            isFavorite: e.isFavorite,
            isLearned: e.isLearned,
          ),
        )
        .toList();
  }

  Future<void> cacheData(List<VocabularyModel> data) async {
    await appDatabase.cacheVocabularies(data);
  }
}
```

## File: lib/features/vocabulary/data/models/category_model.dart
```dart
class CategoryModel {
  final int id;
  final String title;

  CategoryModel({required this.id, required this.title});

  factory CategoryModel.fromJson(Map<String, dynamic> json) {
    return CategoryModel(id: json['id'], title: json['title']);
  }
}
```

## File: lib/features/vocabulary/presentation/pages/vocabulary_detail_page.dart
```dart

```

## File: lib/features/vocabulary/presentation/pages/vocabulary_quiz_page.dart
```dart
import 'dart:math';
import 'package:flutter/material.dart';
import '../../data/models/vocabulary.dart';

class VocabularyQuizPage extends StatefulWidget {
  final List<Vocabulary> vocabList;

  const VocabularyQuizPage({super.key, required this.vocabList});

  @override
  State<VocabularyQuizPage> createState() => _VocabularyQuizPageState();
}

class _VocabularyQuizPageState extends State<VocabularyQuizPage> {
  late Vocabulary current;
  late List<String> options;
  String? selected;
  bool answered = false;

  @override
  void initState() {
    super.initState();
    nextQuestion();
  }

  void nextQuestion() {
    final rnd = Random();

    current = widget.vocabList[rnd.nextInt(widget.vocabList.length)];

    final others =
        widget.vocabList.where((v) => v.id != current.id).toList()..shuffle();

    options = [
      current.meaningEn,
      others[0].meaningEn,
      others[1].meaningEn,
      others[2].meaningEn,
    ]..shuffle();

    selected = null;
    answered = false;

    setState(() {});
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Vocabulary Quiz')),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            Text(
              current.kanji.isNotEmpty ? current.kanji : current.hiragana,
              style: const TextStyle(fontSize: 32, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 24),

            ...options.map((o) {
              final isCorrect = o == current.meaningEn;
              Color? color;

              if (answered) {
                if (o == selected) {
                  color = isCorrect ? Colors.green : Colors.red;
                } else if (isCorrect) {
                  color = Colors.green;
                }
              }

              return Card(
                color: color,
                child: ListTile(
                  title: Text(o),
                  onTap:
                      answered
                          ? null
                          : () {
                            setState(() {
                              selected = o;
                              answered = true;
                            });
                          },
                ),
              );
            }),

            const Spacer(),

            ElevatedButton(
              onPressed: answered ? nextQuestion : null,
              child: const Text('Next'),
            ),
          ],
        ),
      ),
    );
  }
}
```

## File: lib/features/vocabulary/presentation/widgets/vocabulary_card.dart
```dart

```

## File: lib/features/vocabulary/vocabulary_routes.dart
```dart

```

## File: lib/shared/themes/app_theme.dart
```dart

```

## File: lib/shared/widgets/app_button.dart
```dart

```

## File: lib/core/local_db/app_database.dart
```dart
import 'dart:io';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';
import 'package:nihongo_app/features/vocabulary/data/models/vocabulary_model.dart';

import 'tables/local_vocab_progress.dart'; // Import file chứa VocabularyTable

part 'app_database.g.dart';

@DriftDatabase(tables: [VocabularyTable])
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(_openConnection());

  @override
  int get schemaVersion => 1;

  // Lấy tất cả từ vựng từ local
  Future<List<VocabularyTableData>> getAll() => select(vocabularyTable).get();

  // Insert hoặc Update danh sách từ vựng từ Server về
  Future<void> cacheVocabularies(List<VocabularyModel> models) async {
    await batch((batch) {
      for (final model in models) {
        batch.insert(
          vocabularyTable,
          VocabularyTableCompanion.insert(
            id: Value(model.id),
            categoryId: model.categoryId,
            kanji: Value(model.kanji),
            hiragana: Value(model.hiragana),
            romaji: Value(model.romaji),
            meaningVn: Value(model.meaningVn),
            meaningEn: Value(model.meaningEn),
            isFavorite: Value(model.isFavorite),
            isLearned: Value(model.isLearned),
          ),
          mode: InsertMode.insertOrReplace, // Quan trọng: Có rồi thì đè lên
        );
      }
    });
  }
}

LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dir = await getApplicationDocumentsDirectory();
    final file = File(p.join(dir.path, 'nihongo_local.db'));
    return NativeDatabase(file);
  });
}
```

## File: lib/core/local_db/db_instance.dart
```dart
import 'app_database.dart';

final appDatabase = AppDatabase();
```

## File: lib/core/local_db/tables/local_vocab_progress.dart
```dart
import 'package:drift/drift.dart';

// Đổi tên class thành VocabularyTable để phản ánh đúng dữ liệu
class VocabularyTable extends Table {
  // Map fields tương tự VocabularyModel trên Supabase
  IntColumn get id => integer().autoIncrement()();
  IntColumn get categoryId => integer()();
  TextColumn get kanji => text().withDefault(const Constant(''))();
  TextColumn get hiragana => text().withDefault(const Constant(''))();
  TextColumn get romaji => text().withDefault(const Constant(''))();
  TextColumn get meaningVn => text().withDefault(const Constant(''))();
  TextColumn get meaningEn => text().withDefault(const Constant(''))();

  // Progress status
  BoolColumn get isFavorite => boolean().withDefault(const Constant(false))();
  BoolColumn get isLearned => boolean().withDefault(const Constant(false))();

  // Đảm bảo ID khớp với Supabase để sync dễ dàng
  @override
  Set<Column> get primaryKey => {id};
}
```

## File: lib/features/vocabulary/data/datasources/vocabulary_remote_datasource.dart
```dart
// lib/features/vocabulary/data/datasources/vocabulary_remote_datasource.dart

import '../../../../core/services/supabase_service.dart';
import '../models/vocabulary_model.dart';

class VocabularyRemoteDatasource {
  final _client = SupabaseService.client;

  Future<List<VocabularyModel>> getAll() async {
    final response = await _client.from('vocabulary').select().order('id');

    return (response as List).map((e) => VocabularyModel.fromJson(e)).toList();
  }

  Future<void> insert(VocabularyModel vocab) async {
    await _client.from('vocabulary').insert(vocab.toJson());
  }

  Future<void> update(int id, VocabularyModel vocab) async {
    await _client.from('vocabulary').update(vocab.toJson()).eq('id', id);
  }

  Future<void> delete(int id) async {
    await _client.from('vocabulary').delete().eq('id', id);
  }

  Future<void> updateFavorite(int id, bool value) async {
    await _client
        .from('vocabulary')
        .update({'is_favorite': value})
        .eq('id', id);
  }

  Future<void> updateLearned(int id, bool value) async {
    await _client.from('vocabulary').update({'is_learned': value}).eq('id', id);
  }
}
```

## File: lib/features/vocabulary/data/models/vocabulary.dart
```dart
class Vocabulary {
  final int id;
  final int categoryId;
  final String kanji;
  final String hiragana;
  final String romaji;
  final String meaningVn;
  final String meaningEn;
  final bool isFavorite;
  final bool isLearned;

  Vocabulary({
    required this.id,
    required this.categoryId,
    required this.kanji,
    required this.hiragana,
    required this.romaji,
    required this.meaningVn,
    required this.meaningEn,
    required this.isFavorite,
    required this.isLearned,
  });

  factory Vocabulary.fromMap(Map<String, dynamic> map) {
    return Vocabulary(
      id: map['id'],
      categoryId: map['category_id'],
      kanji: map['kanji'] ?? '',
      hiragana: map['hiragana'] ?? '',
      romaji: map['romaji'] ?? '',
      meaningVn: map['meaning_vn'] ?? '',
      meaningEn: map['meaning_en'] ?? '',
      isFavorite: map['is_favorite'] ?? false,
      isLearned: map['is_learned'] ?? false,
    );
  }
}
```

## File: pubspec.yaml
```yaml
name: nihongo_app
description: "A new Flutter project."
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: ^3.7.2

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.8
  supabase_flutter: ^2.12.0

  drift: ^2.16.0
  sqlite3_flutter_libs: ^0.5.20
  path_provider: ^2.1.2
  path: ^1.9.0

dev_dependencies:
  flutter_test:
    sdk: flutter

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^5.0.0
  drift_dev: ^2.16.0
  build_runner: ^2.4.8

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/to/resolution-aware-images

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/to/asset-from-package

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/to/font-from-package
```

## File: lib/features/vocabulary/data/models/vocabulary_model.dart
```dart
// lib/features/vocabulary/data/models/vocabulary_model.dart
import 'vocabulary.dart';

class VocabularyModel {
  final int id;
  final int categoryId;
  final String kanji;
  final String hiragana;
  final String romaji;
  final String wordType;
  final String meaningVn;
  final String meaningEn;
  final bool isFavorite;
  final bool isLearned;

  VocabularyModel({
    required this.id,
    required this.categoryId,
    required this.kanji,
    required this.hiragana,
    required this.romaji,
    required this.wordType,
    required this.meaningVn,
    required this.meaningEn,
    required this.isFavorite,
    required this.isLearned,
  });

  factory VocabularyModel.fromJson(Map<String, dynamic> json) {
    return VocabularyModel(
      id: json['id'],
      categoryId: json['category_id'],
      kanji: json['kanji'] ?? '',
      hiragana: json['hiragana'] ?? '',
      romaji: json['romaji'] ?? '',
      wordType: json['word_type'] ?? '',
      meaningVn: json['meaning_vn'] ?? '',
      meaningEn: json['meaning_en'] ?? '',
      isFavorite: json['is_favorite'] ?? false,
      isLearned: json['is_learned'] ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'category_id': categoryId,
      'kanji': kanji,
      'hiragana': hiragana,
      'romaji': romaji,
      'word_type': wordType,
      'meaning_vn': meaningVn,
      'meaning_en': meaningEn,
      'is_favorite': isFavorite,
      'is_learned': isLearned,
    };
  }

  Vocabulary toEntity() {
    return Vocabulary(
      id: id,
      categoryId: categoryId,
      kanji: kanji,
      hiragana: hiragana,
      romaji: romaji,
      meaningEn: meaningEn,
      meaningVn: meaningVn,
      isFavorite: isFavorite,
      isLearned: isLearned,
    );
  }
}
```

## File: lib/main.dart
```dart
import 'package:flutter/material.dart';
import 'package:nihongo_app/features/vocabulary/presentation/pages/vocabulary_list_page.dart';
import 'core/services/supabase_service.dart';
import 'features/auth/presentation/auth_gate.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await SupabaseService.init();
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Japanese Learning App',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        useMaterial3: true,
      ),
      home: const VocabularyListPage(),
    );
  }
}
```

## File: lib/features/vocabulary/data/repositories/vocabulary_repository.dart
```dart
// lib/features/vocabulary/data/repositories/vocabulary_repository.dart

import '../datasources/vocabulary_remote_datasource.dart';
import '../datasources/vocabulary_local_datasource.dart';
import '../models/vocabulary_model.dart';
import '../models/vocabulary.dart';

class VocabularyRepository {
  final VocabularyRemoteDatasource remoteDatasource;
  final VocabularyLocalDatasource localDatasource = VocabularyLocalDatasource();

  VocabularyRepository(this.remoteDatasource);

  Future<List<Vocabulary>> getAll() async {
    try {
      // 1. Thử lấy data mới nhất từ Server
      final remoteData = await remoteDatasource.getAll();

      // 2. Lưu vào Local DB (Sync)
      await localDatasource.cacheData(remoteData);

      // 3. Trả về data (có thể trả về remoteData luôn, nhưng lấy từ local để đảm bảo nhất quán)
      return _mapToEntity(remoteData);
    } catch (e) {
      // 4. Nếu lỗi mạng/offline -> Lấy từ Local DB
      print('Offline mode: $e');
      final localData = await localDatasource.getAll();
      return _mapToEntity(localData);
    }
  }

  List<Vocabulary> _mapToEntity(List<VocabularyModel> models) {
    return models.map((e) => e.toEntity()).toList();
  }

  Future<void> add(VocabularyModel vocab) {
    return remoteDatasource.insert(vocab);
  }

  Future<void> update(int id, VocabularyModel vocab) {
    return remoteDatasource.update(id, vocab);
  }

  Future<void> delete(int id) {
    return remoteDatasource.delete(id);
  }

  Future<void> toggleFavorite(int id, bool value) async {
    await remoteDatasource.updateFavorite(id, value);
  }

  Future<void> toggleLearned(int id, bool value) async {
    await remoteDatasource.updateLearned(id, value);
  }
}
```

## File: lib/features/vocabulary/presentation/pages/vocabulary_form_page.dart
```dart
import 'package:flutter/material.dart';
import 'package:nihongo_app/features/vocabulary/data/models/vocabulary.dart';

import '../../data/models/vocabulary_model.dart';
import '../../data/repositories/vocabulary_repository.dart';
import '../../data/datasources/vocabulary_remote_datasource.dart';
import '../../data/models/category_model.dart';
import '../../data/datasources/category_remote_datasource.dart';

class VocabularyFormPage extends StatefulWidget {
  final Vocabulary? vocab; // null = create, có = edit

  const VocabularyFormPage({super.key, this.vocab});

  @override
  State<VocabularyFormPage> createState() => _VocabularyFormPageState();
}

class _VocabularyFormPageState extends State<VocabularyFormPage> {
  final _formKey = GlobalKey<FormState>();
  List<CategoryModel> categories = [];
  int? selectedCategoryId;
  late final VocabularyRepository repository;

  final kanjiCtrl = TextEditingController();
  final hiraCtrl = TextEditingController();
  final romajiCtrl = TextEditingController();
  final meaningEnCtrl = TextEditingController();
  final meaningVnCtrl = TextEditingController();

  @override
  void initState() {
    super.initState();
    repository = VocabularyRepository(VocabularyRemoteDatasource());

    if (widget.vocab != null) {
      kanjiCtrl.text = widget.vocab!.kanji;
      hiraCtrl.text = widget.vocab!.hiragana;
      romajiCtrl.text = widget.vocab!.romaji;
      meaningEnCtrl.text = widget.vocab!.meaningEn;
      meaningVnCtrl.text = widget.vocab!.meaningVn;
    }

    CategoryRemoteDatasource().getVocabularyCategories().then((value) {
      setState(() {
        categories = value;

        if (widget.vocab != null) {
          selectedCategoryId = widget.vocab!.categoryId;
        } else if (categories.isNotEmpty) {
          selectedCategoryId = categories.first.id;
        }
      });
    });
  }

  Future<void> _save() async {
    if (!_formKey.currentState!.validate()) return;

    final vocab = VocabularyModel(
      id: widget.vocab?.id ?? 0,
      categoryId: selectedCategoryId!,
      kanji: kanjiCtrl.text,
      hiragana: hiraCtrl.text,
      romaji: romajiCtrl.text,
      wordType: '',
      meaningEn: meaningEnCtrl.text,
      meaningVn: meaningVnCtrl.text,
      isFavorite: false,
      isLearned: false,
    );

    if (widget.vocab == null) {
      await repository.add(vocab);
    } else {
      await repository.update(widget.vocab!.id, vocab);
    }

    if (mounted) Navigator.pop(context, true);
  }

  @override
  Widget build(BuildContext context) {
    final isEdit = widget.vocab != null;

    return Scaffold(
      appBar: AppBar(
        title: Text(isEdit ? 'Edit Vocabulary' : 'Add Vocabulary'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: ListView(
            children: [
              DropdownButtonFormField<int>(
                value: selectedCategoryId,
                decoration: const InputDecoration(labelText: 'Category'),
                items:
                    categories
                        .map(
                          (c) => DropdownMenuItem(
                            value: c.id,
                            child: Text(c.title),
                          ),
                        )
                        .toList(),
                onChanged: (value) {
                  setState(() {
                    selectedCategoryId = value;
                  });
                },
                validator: (v) => v == null ? 'Select category' : null,
              ),

              TextFormField(
                controller: kanjiCtrl,
                decoration: const InputDecoration(labelText: 'Kanji'),
              ),
              TextFormField(
                controller: hiraCtrl,
                decoration: const InputDecoration(labelText: 'Hiragana'),
                validator: (v) => v == null || v.isEmpty ? 'Required' : null,
              ),
              TextFormField(
                controller: romajiCtrl,
                decoration: const InputDecoration(labelText: 'Romaji'),
              ),
              TextFormField(
                controller: meaningEnCtrl,
                decoration: const InputDecoration(labelText: 'Meaning (EN)'),
              ),
              TextFormField(
                controller: meaningVnCtrl,
                decoration: const InputDecoration(labelText: 'Meaning (VN)'),
              ),
              const SizedBox(height: 20),
              ElevatedButton(onPressed: _save, child: const Text('Save')),
            ],
          ),
        ),
      ),
    );
  }
}
```

## File: lib/features/features.txt
```
1️⃣ Mình chỉ bạn Delete (long press)
2️⃣ Gắn Category dropdown cho vocabulary
3️⃣ Refactor lại list cho search

2️⃣ Thêm search + filter vocabulary
3️⃣ Chuẩn bị copy feature này sang Grammar / Kanji

1️⃣ ⭐ Favorite vocabulary
2️⃣ 📊 Learned / Progress
3️⃣ 🔁 Random quiz
4️⃣ 🧠 SRS (ôn tập thông minh)

2️⃣ 📊 Learned / Progress
    1️⃣ Progress bar (JLPT style)
    2️⃣ Filter Learned / Unlearned
    3️⃣ Sort A–Z / Favorite first
    4️⃣ Quiz từ vocab đã learned

3️⃣ 🔁 Random Quiz / Test
    1️⃣ Quiz theo Category / JLPT
    2️⃣ Ghi điểm + streak
    3️⃣ Sai thì auto set learned = false
    4️⃣ Flashcard (lật thẻ)
    5️⃣ Grammar / Kanji quiz dùng lại y chang
    
4️⃣ 🧠 SRS – ôn tập thông minh


Auth
    1️⃣ Login email + Google (Flutter + Supabase)
        1️⃣ Ẩn / hiện CRUD theo role (admin / learner)
        2️⃣ Gắn learned + favorite theo user (cực quan trọng)
        3️⃣ Bật RLS an toàn
        4️⃣ Sync progress đa thiết bị
        4️⃣ Multi-device sync
    2️⃣ Gắn progress vào user (refactor learned/favorite)
    3️⃣ Admin / Learner UI khác nhau
    4️⃣ Offline-first (local cache)

local
1️⃣ Tách learned/favorite: guest vs user
2️⃣ Local cache cho guest (Hive / SharedPreferences)
        🔹 Cách A – SharedPreferences (KHUYÊN DÙNG BÂY GIỜ)
        ✔ Dễ
        ✔ Nhẹ
        ✔ Phù hợp learned / favorite / progress
        ❌ Không phù hợp data lớn

        👉 Dùng cho guest mode (chuẩn)

        🔹 Cách B – SQLite / Drift / Floor

        ✔ Data lớn
        ✔ Query mạnh
        ❌ Code nhiều
        ❌ Dễ ngợp lúc đầu

        👉 Dùng khi:

        Offline full vocab

        Từ điển lớn

        🔹 Cách C – Hive / Isar

        ✔ Nhanh
        ✔ NoSQL
        ✔ App lớn

        👉 Dùng sau này
3️⃣ Sync local → cloud khi login
4️⃣ RLS theo user


Import excel dữ liệu
```

## File: lib/features/vocabulary/presentation/pages/vocabulary_list_page.dart
```dart
import 'package:flutter/material.dart';
import 'package:nihongo_app/features/auth/presentation/login_page.dart';
import 'package:nihongo_app/features/vocabulary/data/datasources/category_remote_datasource.dart';
import 'package:nihongo_app/features/vocabulary/data/models/category_model.dart';
import 'package:nihongo_app/features/vocabulary/presentation/pages/vocabulary_quiz_page.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:nihongo_app/core/ultis/auth_helper.dart';

import '../../data/datasources/vocabulary_remote_datasource.dart';
import '../../data/repositories/vocabulary_repository.dart';
// import '../../data/models/vocabulary_model.dart';
import 'vocabulary_form_page.dart';
import '../../data/models/vocabulary.dart';

class VocabularyListPage extends StatefulWidget {
  const VocabularyListPage({super.key});

  @override
  State<VocabularyListPage> createState() => _VocabularyListPageState();
}

class _VocabularyListPageState extends State<VocabularyListPage> {
  late final VocabularyRepository repository;
  List<Vocabulary> allList = [];
  List<Vocabulary> filteredList = [];
  List<CategoryModel> categories = [];

  bool isLoading = true;
  int? selectedCategoryId;
  String searchText = '';

  @override
  void initState() {
    super.initState();
    CategoryRemoteDatasource().getVocabularyCategories().then((value) {
      setState(() {
        categories = value;
      });
    });
    repository = VocabularyRepository(VocabularyRemoteDatasource());
    loadVocabulary();
  }

  void showLoginHint() {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: const Text('Login to sync your progress'),
        action: SnackBarAction(
          label: 'Login',
          onPressed: () {
            Navigator.push(
              context,
              MaterialPageRoute(builder: (_) => const LoginPage()),
            );
          },
        ),
      ),
    );
  }

  Future<void> loadVocabulary() async {
    setState(() => isLoading = true);

    final data = await repository.getAll();

    setState(() {
      allList = data;
      applyFilter();
      isLoading = false;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Vocabulary'),
        actions: [
          Builder(
            builder: (context) {
              final user = Supabase.instance.client.auth.currentUser;

              if (user == null) {
                return IconButton(
                  icon: const Icon(Icons.login),
                  tooltip: 'Login to sync',
                  onPressed: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(builder: (_) => const LoginPage()),
                    );
                  },
                );
              } else {
                return IconButton(
                  icon: const Icon(Icons.logout),
                  onPressed: () async {
                    await Supabase.instance.client.auth.signOut();
                    ScaffoldMessenger.of(
                      context,
                    ).showSnackBar(const SnackBar(content: Text('Logged out')));
                  },
                );
              }
            },
          ),
          IconButton(
            icon: const Icon(Icons.quiz),
            onPressed: () {
              // chặn khi ít vocab
              if (allList.length < 4) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Need at least 4 vocabularies')),
                );
                return;
              }

              Navigator.push(
                context,
                MaterialPageRoute(
                  builder:
                      (_) => VocabularyQuizPage(
                        vocabList: allList.where((v) => !v.isLearned).toList(),
                      ),
                ),
              );
            },
          ),
          IconButton(
            icon: const Icon(Icons.logout),
            onPressed: () async {
              await Supabase.instance.client.auth.signOut();
            },
          ),
        ],
      ),

      body: Column(
        children: [
          Padding(
            padding: const EdgeInsets.all(8),
            child: TextField(
              decoration: const InputDecoration(
                prefixIcon: Icon(Icons.search),
                hintText: 'Search vocabulary...',
                border: OutlineInputBorder(),
              ),
              onChanged: (value) {
                searchText = value;
                applyFilter();
              },
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8),
            child: DropdownButtonFormField<int>(
              value: selectedCategoryId,
              hint: const Text('Filter by category'),
              items:
                  categories
                      .map(
                        (c) =>
                            DropdownMenuItem(value: c.id, child: Text(c.title)),
                      )
                      .toList(),
              onChanged: (value) {
                selectedCategoryId = value;
                applyFilter();
              },
            ),
          ),

          Expanded(
            child:
                isLoading
                    ? const Center(child: CircularProgressIndicator())
                    : filteredList.isEmpty
                    ? const Center(child: Text('No vocabulary found'))
                    : ListView.builder(
                      itemCount: filteredList.length,
                      itemBuilder: (context, index) {
                        final v = filteredList[index];
                        return ListTile(
                          leading: IconButton(
                            icon: Icon(
                              v.isLearned
                                  ? Icons.check_circle
                                  : Icons.radio_button_unchecked,
                              color: v.isLearned ? Colors.green : Colors.grey,
                            ),
                            onPressed: () async {
                              if (AuthHelper.isGuest) {
                                showLoginHint();
                                return;
                              }

                              await repository.toggleLearned(
                                v.id,
                                !v.isLearned,
                              );
                              loadVocabulary();
                            },
                          ),
                          title: Text(
                            v.kanji.isNotEmpty ? v.kanji : v.hiragana,
                          ),
                          subtitle: Text('${v.meaningEn} / ${v.meaningVn}'),
                          trailing: IconButton(
                            icon: Icon(
                              v.isFavorite ? Icons.star : Icons.star_border,
                              color: v.isFavorite ? Colors.amber : null,
                            ),
                            onPressed: () async {
                              await repository.toggleFavorite(
                                v.id,
                                !v.isFavorite,
                              );
                              loadVocabulary();
                            },
                          ),

                          onTap: () async {
                            final result = await Navigator.push(
                              context,
                              MaterialPageRoute(
                                builder: (_) => VocabularyFormPage(vocab: v),
                              ),
                            );
                            if (result == true) {
                              loadVocabulary();
                            }
                          },
                          onLongPress: () async {
                            final ok = await showDialog<bool>(
                              context: context,
                              builder:
                                  (_) => AlertDialog(
                                    title: const Text('Delete'),
                                    content: const Text(
                                      'Delete this vocabulary?',
                                    ),
                                    actions: [
                                      TextButton(
                                        onPressed:
                                            () => Navigator.pop(context, false),
                                        child: const Text('Cancel'),
                                      ),
                                      TextButton(
                                        onPressed:
                                            () => Navigator.pop(context, true),
                                        child: const Text('Delete'),
                                      ),
                                    ],
                                  ),
                            );
                            if (ok == true) {
                              await repository.delete(v.id);
                              loadVocabulary();
                            }
                          },
                        );
                      },
                    ),
          ),
        ],
      ),

      floatingActionButton: FloatingActionButton(
        onPressed: () async {
          final result = await Navigator.push(
            context,
            MaterialPageRoute(builder: (_) => const VocabularyFormPage()),
          );

          if (result == true) {
            loadVocabulary();
          }
        },
        child: const Icon(Icons.add),
      ),
    );
  }

  void applyFilter() {
    filteredList =
        allList.where((v) {
          final matchCategory =
              selectedCategoryId == null || v.categoryId == selectedCategoryId;

          final text = searchText.toLowerCase();

          final matchSearch =
              text.isEmpty ||
              v.kanji.toLowerCase().contains(text) ||
              v.hiragana.toLowerCase().contains(text) ||
              v.romaji.toLowerCase().contains(text) ||
              v.meaningEn.toLowerCase().contains(text) ||
              v.meaningVn.toLowerCase().contains(text);

          return matchCategory && matchSearch;
        }).toList();

    setState(() {});
  }
}
```
